var initWmeSdkPlus=function(){"use strict";var W=Object.defineProperty,x=(e,t,i)=>t in e?W(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,k=(e,t,i)=>x(e,typeof t!="symbol"?t+"":t,i);let N=class{constructor(t){k(this,"_recognizableHooks",new Map),k(this,"_hookDependencies",new Map),k(this,"_installedHooks",new Map);for(const[i,{hook:n,deps:s}]of Object.entries(t))this._recognizableHooks.set(i,n),s&&this._hookDependencies.set(i,s||[])}isHookInstalled(t,i){const n=this._recognizableHooks.get(i);if(!n||!this._installedHooks.has(t))return!1;const s=this._installedHooks.get(t);return s?s.some(r=>r===n):!1}markHookAsInstalled(t,i){var n;const s=this._recognizableHooks.get(i);if(!s)throw new Error(`Hook ${i} not found`);this._installedHooks.has(t)||this._installedHooks.set(t,[]),(n=this._installedHooks.get(t))==null||n.push(s)}async installHook(t,i){const n=this._recognizableHooks.get(t);if(!n)throw new Error(`Hook ${t} not found`);if(this.isHookInstalled(i,t))return;const s=this._hookDependencies.get(t)||[];for(const r of s)await this.installHook(r,i);await Promise.all(n.map(r=>r.install(i))),this.markHookAsInstalled(i,t)}async installAllHooks(t){for(const i of this._recognizableHooks.keys())await this.installHook(i,t)}};var L=Object.defineProperty,K=(e,t,i)=>t in e?L(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,h=(e,t,i)=>K(e,typeof t!="symbol"?t+"":t,i),C=Object.defineProperty,U=(e,t,i)=>t in e?C(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,g=(e,t,i)=>U(e,typeof t!="symbol"?t+"":t,i),G=Object.defineProperty,J=(e,t,i)=>t in e?G(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,u=(e,t,i)=>J(e,typeof t!="symbol"?t+"":t,i);let Z=class{constructor(t,i){u(this,"_target"),u(this,"_key"),u(this,"_oldValue"),u(this,"_wasDefined",!1),u(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}};const B={onlyIfNotExists:!0};let y=class{constructor(t,i,n={}){if(g(this,"_installedInstances",new Map),g(this,"_path"),g(this,"_targetValue"),g(this,"_options"),this._path=t.split("."),this._path.length===0)throw new Error("Path must not be empty");this._targetValue=i,this._options={...B,...n}}_getTargetObject(t){let i=t;for(const n of this._path.slice(0,this._path.length-1))i[n]||(i[n]={}),i=i[n];return i}_createSwapper(t){const i=this._getTargetObject(t);return new Z(i,this._path.at(-1))}install(t){if(this._installedInstances.has(t))return;const i=this._createSwapper(t);i.value&&this._options.onlyIfNotExists||(i.swap(this._targetValue),this._installedInstances.set(t,i))}uninstall(t){const i=this._installedInstances.get(t);i&&(i.restore(),this._installedInstances.delete(t))}};function A(){return"unsafeWindow"in window?window.unsafeWindow:window}var Q=Object.defineProperty,Y=(e,t,i)=>t in e?Q(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,a=(e,t,i)=>Y(e,typeof t!="symbol"?t+"":t,i);let X=class{constructor(t,i){a(this,"_target"),a(this,"_key"),a(this,"_oldValue"),a(this,"_wasDefined",!1),a(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}},v=class{constructor(t,i,n){a(this,"_enabled",!1),a(this,"_fnSwapper"),a(this,"_interceptionFunction"),a(this,"_middlewares",[]),this._fnSwapper=new X(t,i),this._interceptionFunction=n}get enabled(){return this._fnSwapper.isSwapped&&this._enabled}disable(){this._enabled=!1,this.enabled&&this._fnSwapper.restore()}enable(){this._enabled=!0,this._fnSwapper.isSwapped||this.swapToInterceptor()}swapToInterceptor(){this._fnSwapper.swap((...t)=>{if(!this._enabled)return this.callOriginalInvocator(...t);const i=this.runMiddlewares(t);if(i){if("output"in i)return i.output;"input"in i&&(t=i.input)}return this._interceptionFunction.call(this._fnSwapper.target,this.getOriginalInvocator(),...t)})}getOriginalInvocator(){return this._fnSwapper.originalValue.bind(this._fnSwapper.target)}callOriginalInvocator(...t){return this.getOriginalInvocator()(...t)}runMiddlewares(t){for(const i of this._middlewares){const n=i(...t);if(n){if("output"in n)return n;"input"in n&&(t=n.input)}}return{input:t}}registerMiddleware(t){this._middlewares.push(t)}};function tt(e,t){try{return e()}catch{return t}}let et=class extends v{constructor(t,i,n){super(t,i,n),a(this,"_loggedInvocationRequests",[]),this.registerMiddleware((...s)=>this.logRequest(...s))}logRequest(...t){this._loggedInvocationRequests.push(t)}flushLoggedRequests(){const t=this.getLoggedRequests();return this._loggedInvocationRequests=[],t}getLoggedRequests(){return this._loggedInvocationRequests}executeOriginalLoggedRequests(){this.flushLoggedRequests().forEach(t=>tt(()=>this.callOriginalInvocator(...t)))}},it=class{constructor(){h(this,"_hasResult",!1),h(this,"result")}store(t){return this.result=t,this._hasResult=!0,t}clear(){this.result=void 0,this._hasResult=!1}getResult(){if(this.hasResult)throw new Error("No result is stored");return this.result}get hasResult(){return this._hasResult}};function nt(e){const t=new it;new v(e,"doAction",(i,...n)=>t.hasResult?t.getResult():t.store(i(...n))).enable(),new v(e,"undoAction",(i,...n)=>{const s=i(...n);return t.clear(),s}).enable()}let st=class{constructor(){h(this,"actions",[]),h(this,"undoableActions",[])}acceptAction(t,i){const n={action:t,dataModel:i};t.undoSupported()&&(nt(t),t.doAction(i),this.undoableActions.push(n)),this.actions.push(n)}undoAll(){this.undoableActions.forEach(({action:t,dataModel:i})=>t.undoAction(i))}getActions(){return this.actions.map(({action:t})=>t)}};function rt(){try{return A().require("Waze/Action/MultiAction")}catch{return null}}function at(e){const t=rt();if(!t)throw new Error("Unable to retrieve MultiAction");return new t(e)}let ot=class{constructor(t){h(this,"_activeTransaction",null),h(this,"_actionManagerAddInterceptor"),this._actionManagerAddInterceptor=new et(t,"add",(i,n)=>{var s,r;return(r=(s=this._activeTransaction)==null?void 0:s.acceptAction)==null||r.call(s,n,t.dataModel),!0})}openTransaction(){this._activeTransaction=new st}closeTransaction(){const t=this._activeTransaction;return this._activeTransaction=null,this._actionManagerAddInterceptor.flushLoggedRequests(),t}get hasTransaction(){return this._activeTransaction!==null}beginTransaction(){this.openTransaction()}commitTransaction(t){if(!this.hasTransaction)throw new Error("No open transaction found");try{const i=this._activeTransaction.getActions(),n=at(i);t&&(n._description=t),this._actionManagerAddInterceptor.callOriginalInvocator(n)}catch{this._actionManagerAddInterceptor.executeOriginalLoggedRequests()}finally{this.closeTransaction()}}cancelTransaction(){var t;(t=this._activeTransaction)==null||t.undoAll(),this.closeTransaction()}},I;function m(){if(!I){const e=A();I=new ot(e.W.model.actionManager)}return I}const lt=[new y("Editing.beginTransaction",()=>m().beginTransaction()),new y("Editing.commitTransaction",e=>m().commitTransaction(e)),new y("Editing.cancelTransaction",()=>m().cancelTransaction()),new y("Editing.doActions",(e,t)=>{const i=m();i.beginTransaction();try{e(),i.commitTransaction(t)}catch(n){throw i.cancelTransaction(),n}})];var ht=Object.defineProperty,ut=(e,t,i)=>t in e?ht(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,b=(e,t,i)=>ut(e,typeof t!="symbol"?t+"":t,i),ct=Object.defineProperty,dt=(e,t,i)=>t in e?ct(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,c=(e,t,i)=>dt(e,typeof t!="symbol"?t+"":t,i);let pt=class{constructor(t,i){c(this,"_target"),c(this,"_key"),c(this,"_oldValue"),c(this,"_wasDefined",!1),c(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}};const _t={onlyIfNotExists:!0};let ft=class{constructor(t,i,n={}){if(b(this,"_installedInstances",new Map),b(this,"_path"),b(this,"_targetValue"),b(this,"_options"),this._path=t.split("."),this._path.length===0)throw new Error("Path must not be empty");this._targetValue=i,this._options={..._t,...n}}_getTargetObject(t){let i=t;for(const n of this._path.slice(0,this._path.length-1))i[n]||(i[n]={}),i=i[n];return i}_createSwapper(t){const i=this._getTargetObject(t);return new pt(i,this._path.at(-1))}install(t){if(this._installedInstances.has(t))return;const i=this._createSwapper(t);i.value&&this._options.onlyIfNotExists||(i.swap(this._targetValue),this._installedInstances.set(t,i))}uninstall(t){const i=this._installedInstances.get(t);i&&(i.restore(),this._installedInstances.delete(t))}};function R(){return"unsafeWindow"in window?window.unsafeWindow:window}var wt=Object.defineProperty,gt=(e,t,i)=>t in e?wt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,D=(e,t,i)=>gt(e,typeof t!="symbol"?t+"":t,i);function d(){return"unsafeWindow"in window?window.unsafeWindow:window}var yt=Object.defineProperty,mt=(e,t,i)=>t in e?yt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,o=(e,t,i)=>mt(e,typeof t!="symbol"?t+"":t,i);let bt=class{constructor(t,i){o(this,"_target"),o(this,"_key"),o(this,"_oldValue"),o(this,"_wasDefined",!1),o(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}},St=class{constructor(t,i,n){o(this,"_enabled",!1),o(this,"_fnSwapper"),o(this,"_interceptionFunction"),o(this,"_middlewares",[]),this._fnSwapper=new bt(t,i),this._interceptionFunction=n}get enabled(){return this._fnSwapper.isSwapped&&this._enabled}disable(){this._enabled=!1,this.enabled&&this._fnSwapper.restore()}enable(){this._enabled=!0,this._fnSwapper.isSwapped||this.swapToInterceptor()}swapToInterceptor(){this._fnSwapper.swap((...t)=>{if(!this._enabled)return this.callOriginalInvocator(...t);const i=this.runMiddlewares(t);if(i){if("output"in i)return i.output;"input"in i&&(t=i.input)}return this._interceptionFunction.call(this._fnSwapper.target,this.getOriginalInvocator(),...t)})}getOriginalInvocator(){return this._fnSwapper.originalValue.bind(this._fnSwapper.target)}callOriginalInvocator(...t){return this.getOriginalInvocator()(...t)}runMiddlewares(t){for(const i of this._middlewares){const n=i(...t);if(n){if("output"in n)return n;"input"in n&&(t=n.input)}}return{input:t}}registerMiddleware(t){this._middlewares.push(t)}},kt=class{constructor(t){D(this,"_fetchInterceptor"),D(this,"_interceptionFilters",new Set),this._fetchInterceptor=new St(t,"fetch",(i,n,s)=>{for(const r of this._interceptionFilters)if(r.shouldIntercept(n,s))return this.shouldKeepFilter(r,n,s)||this.removeInterceptionFilter(r),r.intercept(n,s);return i(n,s)})}enable(){this._fetchInterceptor.enable()}disable(){this._fetchInterceptor.disable()}addInterceptionFilter(t){this.enable(),this._interceptionFilters.add(t)}removeInterceptionFilter(t){this._interceptionFilters.delete(t)}shouldKeepFilter(t,i,n){return typeof t.shouldKeep=="function"?t.shouldKeep(i,n):typeof t.shouldKeep=="boolean"?t.shouldKeep:!1}};function vt(e){return e=e instanceof URL?e:new URL(e,d().location.href),t=>typeof t=="string"?new URL(t,d().location.href).pathname===e.pathname:t instanceof URL?t.pathname===e.pathname:new URL(t.url,d().location.href).pathname===new URL(e,d().location.href).pathname}function It(e,t,i){const n=new Response(t,i),s=new URL(e,location.toString());return Object.defineProperty(n,"url",{value:s}),n}function $t(e,t){const i=JSON.stringify(t),n=new Headers({"Content-Type":"application/json"});return It(e,i,{headers:n})}const Ot=new kt(d());function Vt(e){return R().W.controller.descartesClient.getFeatures([0,0,0,0],{[e]:!0},{})}async function jt(e,t){const i=R().W.Config.paths.features;Ot.addInterceptionFilter({shouldIntercept:vt(i),intercept(){return Promise.resolve($t(i,{[e]:{objects:[t]}}))}});const{[e]:n}=await Vt(e),[s]=n.objects;return s.constructor}function Mt(e,t,i={}){const n={type:"Feature"};return(i.id===0||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties={},n.geometry=e,n}function Tt(e,t,i={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!P(e[0])||!P(e[1]))throw new Error("coordinates must contain numbers");return Mt({type:"Point",coordinates:e},t,i)}function P(e){return!isNaN(e)&&e!==null&&!Array.isArray(e)}function z(){return"unsafeWindow"in window?window.unsafeWindow:window}function Et(e){const t=z().require("Waze/Action/CreateObject");return new t(e)}function At(e){z().W.model.actionManager.add(Et(e))}function Rt(e){return e.toISOString().slice(0,16).replace("T"," ")}let $;function Dt(){if(!$)throw new Error("MapComment not initialized. Make sure to await the enhancedSDK function before using it.")}const Pt=[{async install(){$=await jt("mapComments",{geometry:Tt([0,0]).geometry})}},new ft("DataModel.MapComments.addMapComment",e=>{Dt();const t=new $({geoJSONGeometry:e.geoJSONGeometry,subject:e.subject,body:e.body,lockRank:e.lockRank,endDate:e.endDate?Rt(e.endDate):null});return At(t),t})];var zt=Object.defineProperty,Ft=(e,t,i)=>t in e?zt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,S=(e,t,i)=>Ft(e,typeof t!="symbol"?t+"":t,i),Ht=Object.defineProperty,qt=(e,t,i)=>t in e?Ht(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,p=(e,t,i)=>qt(e,typeof t!="symbol"?t+"":t,i);let Wt=class{constructor(e,t){p(this,"_target"),p(this,"_key"),p(this,"_oldValue"),p(this,"_wasDefined",!1),p(this,"_isSwapped",!1),this._target=e,this._key=t,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(e){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=e,this._isSwapped=!0}};const xt={onlyIfNotExists:!0};class Nt{constructor(t,i,n={}){if(S(this,"_installedInstances",new Map),S(this,"_path"),S(this,"_targetValue"),S(this,"_options"),this._path=t.split("."),this._path.length===0)throw new Error("Path must not be empty");this._targetValue=i,this._options={...xt,...n}}_getTargetObject(t){let i=t;for(const n of this._path.slice(0,this._path.length-1))i[n]||(i[n]={}),i=i[n];return i}_createSwapper(t){const i=this._getTargetObject(t);return new Wt(i,this._path.at(-1))}install(t){if(this._installedInstances.has(t))return;const i=this._createSwapper(t);i.value&&this._options.onlyIfNotExists||(i.swap(this._targetValue),this._installedInstances.set(t,i))}uninstall(t){const i=this._installedInstances.get(t);i&&(i.restore(),this._installedInstances.delete(t))}}var Lt=Object.defineProperty,Kt=(e,t,i)=>t in e?Lt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,_=(e,t,i)=>Kt(e,typeof t!="symbol"?t+"":t,i);let F=class{constructor(e,t){_(this,"_target"),_(this,"_key"),_(this,"_oldValue"),_(this,"_wasDefined",!1),_(this,"_isSwapped",!1),this._target=e,this._key=t,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(e){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=e,this._isSwapped=!0}};function O(){return"unsafeWindow"in window?window.unsafeWindow:window}async function Ct(e){const t=[],i=new F(O().W.model.actionManager,"add");i.swap(n=>{t.push(n)});try{await e()}finally{i.restore()}return t}function Ut(e){return e.memoizedProps||{}}function Gt(e){return typeof e=="object"&&e!==null&&"memoizedState"in e&&Array.isArray(e.memoizedState)&&e.memoizedState.length===2&&"queue"in e&&e.queue===null&&Array.isArray(e.memoizedState[1])}function Jt(e){return typeof e=="object"&&e!==null&&"memoizedState"in e&&typeof e.memoizedState=="object"&&e.memoizedState!==null&&"current"in e.memoizedState&&"queue"in e&&e.queue===null}function Zt(e){return typeof e=="object"&&e!==null&&"memoizedState"in e&&"queue"in e&&typeof e.queue=="object"&&e.queue!==null&&"dispatch"in e.queue&&typeof e.queue.dispatch=="function"}function Bt(e){return Zt(e)?{type:"useState",value:e.memoizedState,dispatch:e.queue.dispatch}:Gt(e)?{type:"useMemo",value:e.memoizedState[0],dependencies:e.memoizedState[1]}:Jt(e)?{type:"useRef",current:e.memoizedState}:null}function Qt(e,t){const i=[];let n=e.memoizedState;for(;n;){const s=Bt(n);s&&i.push(s),n=n.next}return i}function Yt(e,t,i=1/0){let n=e,s=0;for(;n&&s<i;){const r=n.memoizedState?Qt(n):[],E=Ut(n),f={fiber:n,hooks:{all:r,useState:r.filter(w=>w.type==="useState"),useMemo:r.filter(w=>w.type==="useMemo"),useRef:r.filter(w=>w.type==="useRef")},props:E};if(t(f))return f;n=n.return,s++}return null}const Xt="__reactFiber$";function te(e){const t=Object.keys(e).find(n=>n.startsWith(Xt));if(!t)throw new Error(`No fiber key found for element: ${e}`);const i=e[t];if(!i)throw new Error(`No fiber found for element: ${e}`);return i}const ee=e=>new Promise(t=>{const i=O(),n=new F(i.W.map.olMap,"addControl");n.swap(s=>{e==null||e(s),t(s),n.restore()})});function ie(e){const t=O(),i=t.W.userscripts.toOLGeometry(e);return new t.OpenLayers.Feature.Vector(i)}async function ne(e,t){const i=Yt(te(e),r=>"onClick"in r.props&&typeof r.props.onClick=="function");if(!i)throw new Error("No fiber found with draw initiator");const{onClick:n}=i.props;//! OpenLayers dependent code below - implementation might change over time
const s=ee(r=>{r.activate=()=>{}});n(new Event("click")),(await s).events.triggerEvent("featureadded",{feature:ie(t)})}var se=Object.defineProperty,re=(e,t,i)=>t in e?se(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,H=(e,t,i)=>re(e,typeof t!="symbol"?t+"":t,i);function ae(){return"unsafeWindow"in window?window.unsafeWindow:window}var oe=Object.defineProperty,le=(e,t,i)=>t in e?oe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,l=(e,t,i)=>le(e,typeof t!="symbol"?t+"":t,i);class he{constructor(t,i){l(this,"_target"),l(this,"_key"),l(this,"_oldValue"),l(this,"_wasDefined",!1),l(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}}class ue{constructor(t,i,n){l(this,"_enabled",!1),l(this,"_fnSwapper"),l(this,"_interceptionFunction"),l(this,"_middlewares",[]),this._fnSwapper=new he(t,i),this._interceptionFunction=n}get enabled(){return this._fnSwapper.isSwapped&&this._enabled}disable(){this._enabled=!1,this.enabled&&this._fnSwapper.restore()}enable(){this._enabled=!0,this._fnSwapper.isSwapped||this.swapToInterceptor()}swapToInterceptor(){this._fnSwapper.swap((...t)=>{if(!this._enabled)return this.callOriginalInvocator(...t);const i=this.runMiddlewares(t);if(i){if("output"in i)return i.output;"input"in i&&(t=i.input)}return this._interceptionFunction.call(this._fnSwapper.target,this.getOriginalInvocator(),...t)})}getOriginalInvocator(){return this._fnSwapper.originalValue.bind(this._fnSwapper.target)}callOriginalInvocator(...t){return this.getOriginalInvocator()(...t)}runMiddlewares(t){for(const i of this._middlewares){const n=i(...t);if(n){if("output"in n)return n;"input"in n&&(t=n.input)}}return{input:t}}registerMiddleware(t){this._middlewares.push(t)}}class ce{constructor(t){H(this,"_fetchInterceptor"),H(this,"_interceptionFilters",new Set),this._fetchInterceptor=new ue(t,"fetch",(i,n,s)=>{for(const r of this._interceptionFilters)if(r.shouldIntercept(n,s))return this.shouldKeepFilter(r,n,s)||this.removeInterceptionFilter(r),r.intercept(n,s);return i(n,s)})}enable(){this._fetchInterceptor.enable()}disable(){this._fetchInterceptor.disable()}addInterceptionFilter(t){this.enable(),this._interceptionFilters.add(t)}removeInterceptionFilter(t){this._interceptionFilters.delete(t)}shouldKeepFilter(t,i,n){return typeof t.shouldKeep=="function"?t.shouldKeep(i,n):typeof t.shouldKeep=="boolean"?t.shouldKeep:!1}}new ce(ae());function de(e,t,i={}){const n={type:"Feature"};return(i.id===0||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties={},n.geometry=e,n}function pe(e,t,i={}){for(const n of e){if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(n[n.length-1].length!==n[0].length)throw new Error("First and last Position are not equivalent.");for(let s=0;s<n[n.length-1].length;s++)if(n[n.length-1][s]!==n[0][s])throw new Error("First and last Position are not equivalent.")}return de({type:"Polygon",coordinates:e},t,i)}function _e(){return"unsafeWindow"in window?window.unsafeWindow:window}function fe(e,t,i){const n=new e(i),s=new t(n);return _e().W.model.actionManager.add(s),n}let V,j;const we=[{async install(){const e=document.querySelector("#drawer wz-menu > wz-menu-sub-menu:nth-child(3) > wz-menu-item:nth-of-type(2)");if(!e||!(e instanceof HTMLElement))throw new Error("Unable to find school zone drawing menu item");const[t]=await Ct(async()=>{await ne(e,pe([[[0,0],[0,1],[1,1],[0,0]]]).geometry)});if(t.actionName!=="ADD_PERMANENT_HAZARD")throw new Error("Unexpected action discovered when tried to resolve AddPermanentHazard action: "+t.actionName);const i=t.object;if(!i)throw new Error("Unexpected state: Added object does not exist");if(i.type!=="permanentHazard")throw new Error("Unexpected state: Expected the added object to be a PermanentHazard instead of "+t.type);V=t.constructor,j=i.constructor}},new Nt("DataModel.PermanentHazards.addSchoolZone",e=>{if(!j||!V)throw new Error("PermanentHazard or AddPermanentHazard are not initialized. Make sure to await the enhancedSDK function before using it.");return fe(j,V,{type:9,geoJSONGeometry:e.geometry,name:e.name,speedLimit:e.speedLimit,excludedRoadTypes:e.excludedRoadTypes})})],ge={"Editing.Transactions":{hook:lt},"DataModel.MapComments":{hook:Pt},"DataModel.PermanentHazards":{hook:we}};function M(e){const[t,i,n]=e.split(".").map(Number);return{major:t,minor:i,patch:n}}function T(e,t){return e?t?e.major&&t.major&&e.major!==t.major?e.major-t.major:e.minor&&t.minor&&e.minor!==t.minor?e.minor-t.minor:e.patch&&t.patch&&e.patch!==t.patch?e.patch-t.patch:0:1:-1}function ye(e,t,i="highest"){let n=null;typeof e.highest=="string"&&(e.highest=M(e.highest)),typeof e.lowest=="string"&&(e.lowest=M(e.lowest));for(const s of t){if(!s.version)continue;if(!n){n=s;continue}if(e.highest&&T(s.version,e.highest)>0||e.lowest&&T(s.version,e.lowest)<0)continue;const r=s.version,E=n.version,f=T(r,E);(i==="highest"&&f>0||i==="lowest"&&f<0)&&(n=s)}if(!n)throw new Error("No matching version found");return n}const me={"0.1":e=>{const t=e.constructor;return new t(e.getScriptId(),e.getScriptName())}};function be(e){const t=Object.entries(me).map(([n,s])=>({version:M(n),cloner:s})),{cloner:i}=ye({highest:e.getSDKVersion()},t);return i(e)}const q=new N(ge);async function Se(e,t={}){if(t.immutable&&(e=be(e)),t.hooks)for(const i of t.hooks)await q.installHook(i,e);else await q.installAllHooks(e);return e}return Se}();
