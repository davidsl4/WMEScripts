var initWmeSdkPlus=function(){"use strict";var M=Object.defineProperty,j=(e,t,i)=>t in e?M(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,g=(e,t,i)=>j(e,typeof t!="symbol"?t+"":t,i);let A=class{constructor(t){g(this,"_recognizableHooks",new Map),g(this,"_hookDependencies",new Map),g(this,"_installedHooks",new Map);for(const[i,{hook:n,deps:s}]of Object.entries(t))this._recognizableHooks.set(i,n),s&&this._hookDependencies.set(i,s||[])}isHookInstalled(t,i){const n=this._recognizableHooks.get(i);if(!n||!this._installedHooks.has(t))return!1;const s=this._installedHooks.get(t);return s?s.some(r=>r===n):!1}markHookAsInstalled(t,i){var n;const s=this._recognizableHooks.get(i);if(!s)throw new Error(`Hook ${i} not found`);this._installedHooks.has(t)||this._installedHooks.set(t,[]),(n=this._installedHooks.get(t))==null||n.push(s)}async installHook(t,i){const n=this._recognizableHooks.get(t);if(!n)throw new Error(`Hook ${t} not found`);if(this.isHookInstalled(i,t))return;const s=this._hookDependencies.get(t)||[];for(const r of s)await this.installHook(r,i);await Promise.all(n.map(r=>r.install(i))),this.markHookAsInstalled(i,t)}async installAllHooks(t){for(const i of this._recognizableHooks.keys())await this.installHook(i,t)}};var $=Object.defineProperty,E=(e,t,i)=>t in e?$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,l=(e,t,i)=>E(e,typeof t!="symbol"?t+"":t,i),H=Object.defineProperty,D=(e,t,i)=>t in e?H(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,p=(e,t,i)=>D(e,typeof t!="symbol"?t+"":t,i),F=Object.defineProperty,P=(e,t,i)=>t in e?F(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,h=(e,t,i)=>P(e,typeof t!="symbol"?t+"":t,i);let W=class{constructor(t,i){h(this,"_target"),h(this,"_key"),h(this,"_oldValue"),h(this,"_wasDefined",!1),h(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}};const q={onlyIfNotExists:!0};class d{constructor(t,i,n={}){if(p(this,"_installedInstances",new Map),p(this,"_path"),p(this,"_targetValue"),p(this,"_options"),this._path=t.split("."),this._path.length===0)throw new Error("Path must not be empty");this._targetValue=i,this._options={...q,...n}}_getTargetObject(t){let i=t;for(const n of this._path.slice(0,this._path.length-1))i[n]||(i[n]={}),i=i[n];return i}_createSwapper(t){const i=this._getTargetObject(t);return new W(i,this._path.at(-1))}install(t){if(this._installedInstances.has(t))return;const i=this._createSwapper(t);i.value&&this._options.onlyIfNotExists||(i.swap(this._targetValue),this._installedInstances.set(t,i))}uninstall(t){const i=this._installedInstances.get(t);i&&(i.restore(),this._installedInstances.delete(t))}}function S(){return"unsafeWindow"in window?window.unsafeWindow:window}var L=Object.defineProperty,N=(e,t,i)=>t in e?L(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,a=(e,t,i)=>N(e,typeof t!="symbol"?t+"":t,i);let x=class{constructor(t,i){a(this,"_target"),a(this,"_key"),a(this,"_oldValue"),a(this,"_wasDefined",!1),a(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}},w=class{constructor(t,i,n){a(this,"_enabled",!1),a(this,"_fnSwapper"),a(this,"_interceptionFunction"),a(this,"_middlewares",[]),this._fnSwapper=new x(t,i),this._interceptionFunction=n}get enabled(){return this._fnSwapper.isSwapped&&this._enabled}disable(){this._enabled=!1,this.enabled&&this._fnSwapper.restore()}enable(){this._enabled=!0,this._fnSwapper.isSwapped||this.swapToInterceptor()}swapToInterceptor(){this._fnSwapper.swap((...t)=>{if(!this._enabled)return this.callOriginalInvocator(...t);const i=this.runMiddlewares(t);if(i){if("output"in i)return i.output;"input"in i&&(t=i.input)}return this._interceptionFunction.call(this._fnSwapper.target,this.getOriginalInvocator(),...t)})}getOriginalInvocator(){return this._fnSwapper.originalValue.bind(this._fnSwapper.target)}callOriginalInvocator(...t){return this.getOriginalInvocator()(...t)}runMiddlewares(t){for(const i of this._middlewares){const n=i(...t);if(n){if("output"in n)return n;"input"in n&&(t=n.input)}}return{input:t}}registerMiddleware(t){this._middlewares.push(t)}};function C(e,t){try{return e()}catch{return t}}let K=class extends w{constructor(t,i,n){super(t,i,n),a(this,"_loggedInvocationRequests",[]),this.registerMiddleware((...s)=>this.logRequest(...s))}logRequest(...t){this._loggedInvocationRequests.push(t)}flushLoggedRequests(){const t=this.getLoggedRequests();return this._loggedInvocationRequests=[],t}getLoggedRequests(){return this._loggedInvocationRequests}executeOriginalLoggedRequests(){this.flushLoggedRequests().forEach(t=>C(()=>this.callOriginalInvocator(...t)))}},z=class{constructor(){l(this,"_hasResult",!1),l(this,"result")}store(t){return this.result=t,this._hasResult=!0,t}clear(){this.result=void 0,this._hasResult=!1}getResult(){if(this.hasResult)throw new Error("No result is stored");return this.result}get hasResult(){return this._hasResult}};function U(e){const t=new z;new w(e,"doAction",(i,...n)=>t.hasResult?t.getResult():t.store(i(...n))).enable(),new w(e,"undoAction",(i,...n)=>{const s=i(...n);return t.clear(),s}).enable()}let J=class{constructor(){l(this,"actions",[]),l(this,"undoableActions",[])}acceptAction(t,i){const n={action:t,dataModel:i};t.undoSupported()&&(U(t),t.doAction(i),this.undoableActions.push(n)),this.actions.push(n)}undoAll(){this.undoableActions.forEach(({action:t,dataModel:i})=>t.undoAction(i))}getActions(){return this.actions.map(({action:t})=>t)}};function G(){try{return S().require("Waze/Action/MultiAction")}catch{return null}}function B(e){const t=G();if(!t)throw new Error("Unable to retrieve MultiAction");return new t(e)}let Q=class{constructor(t){l(this,"_activeTransaction",null),l(this,"_actionManagerAddInterceptor"),this._actionManagerAddInterceptor=new K(t,"add",(i,n)=>{var s,r;return(r=(s=this._activeTransaction)==null?void 0:s.acceptAction)==null||r.call(s,n,t.dataModel),!0})}openTransaction(){this._activeTransaction=new J}closeTransaction(){const t=this._activeTransaction;return this._activeTransaction=null,this._actionManagerAddInterceptor.flushLoggedRequests(),t}get hasTransaction(){return this._activeTransaction!==null}beginTransaction(){this.openTransaction()}commitTransaction(t){if(!this.hasTransaction)throw new Error("No open transaction found");try{const i=this._activeTransaction.getActions(),n=B(i);t&&(n._description=t),this._actionManagerAddInterceptor.callOriginalInvocator(n)}catch{this._actionManagerAddInterceptor.executeOriginalLoggedRequests()}finally{this.closeTransaction()}}cancelTransaction(){var t;(t=this._activeTransaction)==null||t.undoAll(),this.closeTransaction()}},b;function _(){if(!b){const e=S();b=new Q(e.W.model.actionManager)}return b}const X=[new d("Editing.beginTransaction",()=>_().beginTransaction()),new d("Editing.commitTransaction",e=>_().commitTransaction(e)),new d("Editing.cancelTransaction",()=>_().cancelTransaction()),new d("Editing.doActions",(e,t)=>{const i=_();i.beginTransaction();try{e(),i.commitTransaction(t)}catch(n){throw i.cancelTransaction(),n}})];var Y=Object.defineProperty,Z=(e,t,i)=>t in e?Y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,f=(e,t,i)=>Z(e,typeof t!="symbol"?t+"":t,i),tt=Object.defineProperty,et=(e,t,i)=>t in e?tt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,c=(e,t,i)=>et(e,typeof t!="symbol"?t+"":t,i);let it=class{constructor(e,t){c(this,"_target"),c(this,"_key"),c(this,"_oldValue"),c(this,"_wasDefined",!1),c(this,"_isSwapped",!1),this._target=e,this._key=t,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(e){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=e,this._isSwapped=!0}};const nt={onlyIfNotExists:!0};let st=class{constructor(e,t,i={}){if(f(this,"_installedInstances",new Map),f(this,"_path"),f(this,"_targetValue"),f(this,"_options"),this._path=e.split("."),this._path.length===0)throw new Error("Path must not be empty");this._targetValue=t,this._options={...nt,...i}}_getTargetObject(e){let t=e;for(const i of this._path.slice(0,this._path.length-1))t[i]||(t[i]={}),t=t[i];return t}_createSwapper(e){const t=this._getTargetObject(e);return new it(t,this._path.at(-1))}install(e){if(this._installedInstances.has(e))return;const t=this._createSwapper(e);t.value&&this._options.onlyIfNotExists||(t.swap(this._targetValue),this._installedInstances.set(e,t))}uninstall(e){const t=this._installedInstances.get(e);t&&(t.restore(),this._installedInstances.delete(e))}};function v(){return"unsafeWindow"in window?window.unsafeWindow:window}var rt=Object.defineProperty,at=(e,t,i)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,I=(e,t,i)=>at(e,typeof t!="symbol"?t+"":t,i);function u(){return"unsafeWindow"in window?window.unsafeWindow:window}var ot=Object.defineProperty,lt=(e,t,i)=>t in e?ot(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,o=(e,t,i)=>lt(e,typeof t!="symbol"?t+"":t,i);class ht{constructor(t,i){o(this,"_target"),o(this,"_key"),o(this,"_oldValue"),o(this,"_wasDefined",!1),o(this,"_isSwapped",!1),this._target=t,this._key=i,this._oldValue=this._target[this._key]}get isSwapped(){return this._isSwapped}get originalValue(){return this._oldValue}get value(){return this._target[this._key]}get target(){return this._target}restore(){this.isSwapped&&(this._wasDefined?this._target[this._key]=this._oldValue:delete this._target[this._key],this._isSwapped=!1)}swap(t){this.isSwapped||(this._wasDefined=Object.hasOwn(this._target,this._key),this._oldValue=this._target[this._key]),this._target[this._key]=t,this._isSwapped=!0}}class ct{constructor(t,i,n){o(this,"_enabled",!1),o(this,"_fnSwapper"),o(this,"_interceptionFunction"),o(this,"_middlewares",[]),this._fnSwapper=new ht(t,i),this._interceptionFunction=n}get enabled(){return this._fnSwapper.isSwapped&&this._enabled}disable(){this._enabled=!1,this.enabled&&this._fnSwapper.restore()}enable(){this._enabled=!0,this._fnSwapper.isSwapped||this.swapToInterceptor()}swapToInterceptor(){this._fnSwapper.swap((...t)=>{if(!this._enabled)return this.callOriginalInvocator(...t);const i=this.runMiddlewares(t);if(i){if("output"in i)return i.output;"input"in i&&(t=i.input)}return this._interceptionFunction.call(this._fnSwapper.target,this.getOriginalInvocator(),...t)})}getOriginalInvocator(){return this._fnSwapper.originalValue.bind(this._fnSwapper.target)}callOriginalInvocator(...t){return this.getOriginalInvocator()(...t)}runMiddlewares(t){for(const i of this._middlewares){const n=i(...t);if(n){if("output"in n)return n;"input"in n&&(t=n.input)}}return{input:t}}registerMiddleware(t){this._middlewares.push(t)}}class ut{constructor(t){I(this,"_fetchInterceptor"),I(this,"_interceptionFilters",new Set),this._fetchInterceptor=new ct(t,"fetch",(i,n,s)=>{for(const r of this._interceptionFilters)if(r.shouldIntercept(n,s))return this.shouldKeepFilter(r,n,s)||this.removeInterceptionFilter(r),r.intercept(n,s);return i(n,s)})}enable(){this._fetchInterceptor.enable()}disable(){this._fetchInterceptor.disable()}addInterceptionFilter(t){this.enable(),this._interceptionFilters.add(t)}removeInterceptionFilter(t){this._interceptionFilters.delete(t)}shouldKeepFilter(t,i,n){return typeof t.shouldKeep=="function"?t.shouldKeep(i,n):typeof t.shouldKeep=="boolean"?t.shouldKeep:!1}}function pt(e){return e=e instanceof URL?e:new URL(e,u().location.href),t=>typeof t=="string"?new URL(t,u().location.href).pathname===e.pathname:t instanceof URL?t.pathname===e.pathname:new URL(t.url,u().location.href).pathname===new URL(e,u().location.href).pathname}function dt(e,t,i){const n=new Response(t,i),s=new URL(e,location.toString());return Object.defineProperty(n,"url",{value:s}),n}function _t(e,t){const i=JSON.stringify(t),n=new Headers({"Content-Type":"application/json"});return dt(e,i,{headers:n})}const ft=new ut(u());function gt(e){return v().W.controller.descartesClient.getFeatures([0,0,0,0],{[e]:!0},{})}async function wt(e,t){const i=v().W.Config.paths.features;ft.addInterceptionFilter({shouldIntercept:pt(i),intercept(){return Promise.resolve(_t(i,{[e]:{objects:[t]}}))}});const{[e]:n}=await gt(e),[s]=n.objects;return s.constructor}function bt(e,t,i={}){const n={type:"Feature"};return(i.id===0||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties={},n.geometry=e,n}function yt(e,t,i={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!O(e[0])||!O(e[1]))throw new Error("coordinates must contain numbers");return bt({type:"Point",coordinates:e},t,i)}function O(e){return!isNaN(e)&&e!==null&&!Array.isArray(e)}function V(){return"unsafeWindow"in window?window.unsafeWindow:window}function mt(e){const t=V().require("Waze/Action/CreateObject");return new t(e)}function kt(e){V().W.model.actionManager.add(mt(e))}function St(e){return e.toISOString().slice(0,16).replace("T"," ")}let y;function vt(){if(!y)throw new Error("MapComment not initialized. Make sure to await the enhancedSDK function before using it.")}const It=[{async install(){y=await wt("mapComments",{geometry:yt([0,0]).geometry})}},new st("DataModel.MapComments.addMapComment",e=>{vt();const t=new y({geoJSONGeometry:e.geoJSONGeometry,subject:e.subject,body:e.body,lockRank:e.lockRank,endDate:e.endDate?St(e.endDate):null});return kt(t),t})],Ot={"Editing.Transactions":{hook:X},"DataModel.MapComments":{hook:It}};function m(e){const[t,i,n]=e.split(".").map(Number);return{major:t,minor:i,patch:n}}function k(e,t){return e?t?e.major&&t.major&&e.major!==t.major?e.major-t.major:e.minor&&t.minor&&e.minor!==t.minor?e.minor-t.minor:e.patch&&t.patch&&e.patch!==t.patch?e.patch-t.patch:0:1:-1}function Vt(e,t,i="highest"){let n=null;typeof e.highest=="string"&&(e.highest=m(e.highest)),typeof e.lowest=="string"&&(e.lowest=m(e.lowest));for(const s of t){if(!s.version)continue;if(!n){n=s;continue}if(e.highest&&k(s.version,e.highest)>0||e.lowest&&k(s.version,e.lowest)<0)continue;const r=s.version,jt=n.version,R=k(r,jt);(i==="highest"&&R>0||i==="lowest"&&R<0)&&(n=s)}if(!n)throw new Error("No matching version found");return n}const Tt={"0.1":e=>{const t=e.constructor;return new t(e.getScriptId(),e.getScriptName())}};function Rt(e){const t=Object.entries(Tt).map(([n,s])=>({version:m(n),cloner:s})),{cloner:i}=Vt({highest:e.getSDKVersion()},t);return i(e)}const T=new A(Ot);async function Mt(e,t={}){if(t.immutable&&(e=Rt(e)),t.hooks)for(const i of t.hooks)await T.installHook(i,e);else await T.installAllHooks(e);return e}return Mt}();
